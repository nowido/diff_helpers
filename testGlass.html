<html>
    <head>
        <meta charset=utf-8>
        <title>Glass test</title>
    </head>
    <body>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
        <script src="glass/glassCore.js"></script>
        <script src="examples/glassplay.2.js"></script>
        
        <script type="x-shader/x-fragment" id="commonKernelRoutines">
            
            #define readInput texture2D
            
            precision highp float;
            
            vec2 getThreadId()     
            {
                return floor(gl_FragCoord.xy);
            }
            
            void writeOutput(vec4 value)
            {
                gl_FragColor = value;
            }
            
            vec2 buildAddress(vec2 addrOffset, vec2 addrUnit, vec2 pos)
            {
                return addrOffset + addrUnit * pos;    
            }
            
            float safeDivide(float value, float tryDivisor)
            {
                return (abs(tryDivisor) > 0.0) ? (value / tryDivisor) : value;    
            }
            
            vec4 safeDivide(vec4 value, vec4 tryDivisor)
            {
                vec4 divided = value / tryDivisor;
                
                vec4 absDivisor = abs(tryDivisor);
                
                vec4 outputValue;

                outputValue.x = (absDivisor.x > 0.0) ? divided.x : value.x;
                outputValue.y = (absDivisor.y > 0.0) ? divided.y : value.y;
                outputValue.z = (absDivisor.z > 0.0) ? divided.z : value.z;
                outputValue.w = (absDivisor.w > 0.0) ? divided.w : value.w;
                
                return outputValue;
            }
            
            float convertUnorm4ToFloat(vec4 nv)
            {
                // nv   x  y  z  w
                //      0  8  16 24
                
                //      w z y x
                //      high -> low
                
                //nv = floor(255.0 * nv + 0.5);
                nv *= 255.0;
                
                bool signBit = (nv.w > 127.0);
                
                float expHigh = nv.w - (signBit ? 128.0 : 0.0);
                float expLow = (nv.z > 127.0) ? 1.0 : 0.0;
                float expShifted = expHigh * 2.0 + expLow;
                
                bool denorm = (expShifted == 0.0);

                float mantHigh = nv.z - ((expLow > 0.0) ? 128.0 : 0.0);
                //float mantMid = nv.y;
                //float mantLow = nv.x;
                
                vec2 expWithMantissa = vec2(expShifted - 127.0, (mantHigh * 65536.0 + nv.y * 256.0 + nv.x) / 8388608.0);
                
                expWithMantissa += denorm ? vec2(1.0, 0.0) : vec2(0.0, 1.0);

                return exp2(expWithMantissa.x) * expWithMantissa.y * (signBit ? -1.0 : 1.0);
            }
            
            vec4 convertFloatToUnorm4(float fv)
            {
                vec4 result;
                
                //      w z y x
                //      high -> low
                
                bool sign = (fv < 0.0);
                
                fv *= (sign ? -1.0 : 1.0);
                
                float exponent = (fv != 0.0) ? floor(log2(fv)) : -127.0;
                float expSh = exponent + 127.0;
                
                bool denorm = (expSh == 0.0);
                
                float expHigh = floor(expSh / 2.0);
                float expLow = mod(expSh, 2.0);
                
                float mant = fv / exp2(exponent);
                
                mant *= denorm ? 0.5 : 1.0;
                mant -= denorm ? 0.0 : 1.0;
                
                float mantInt = floor(mant * 8388608.0);
                float mantHigh = floor(mantInt / 65536.0);
                
                result.w = expHigh + (sign ? 128.0 : 0.0);
                result.z = mantHigh + ((expLow > 0.0) ? 128.0 : 0.0);
                
                float tmp = mantInt - mantHigh * 65536.0;
                
                result.y = floor(tmp / 256.0);
                result.x = floor(tmp - result.y * 256.0);
                
                return result / 255.0;
            }
            
            float readFloat(sampler2D resource, vec2 coords)
            {
                return convertUnorm4ToFloat(readInput(resource, coords));
            }
            
            void writeFloat(float fv)
            {
                gl_FragColor = convertFloatToUnorm4(fv);    
            }
            
        </script>
        
        <script type="x-shader/x-fragment" id="justTransfer">
        
            // #define WIDTH
            // #define HEIGHT

            // WIDTH is N
            // HEIGHT is (N + 1)
            
                // matrix is augmented with vector and transposed (so vector is last row)
            
            uniform highp sampler2D matrix;
        
                // 2D fetch coords helpers
                
            const vec2 addrUnit = vec2(1.0, 1.0) / vec2(WIDTH, HEIGHT);
            const vec2 addrOffset = vec2(0.5, 0.5) * addrUnit;
        
            void main()
            {
                vec2 id = getThreadId();
                
                float valf = readFloat(matrix, buildAddress(addrOffset, addrUnit, id));

                writeFloat(valf + 0.5);
            }
            
        </script>
        
        <script type="x-shader/x-fragment" id="eliminator2">
            // #define WIDTH
            // #define HEIGHT
            
            // WIDTH is N
            // HEIGHT is (N + 1)
            
                // matrix is augmented with vector and transposed (so vector is last row)
            
            uniform highp sampler2D matrix;
            
                // 2D-dispatch coord                
            
            uniform vec2 leftTop;
            
                // as matrix is, in fact, combined from 4 'layers',
                // lead indices are different, in general

            uniform vec4 leadIndex;
            
                // 2D fetch coords helpers
                
            const vec2 addrUnit = vec2(1.0, 1.0) / vec2(WIDTH, HEIGHT);
            const vec2 addrOffset = vec2(0.5, 0.5) * addrUnit;

                //
                
            void main()
            {
                    // we have 2D-identity
                    
                vec2 id = getThreadId();
                
                    //
                
                bool weAreLeft = (id.x == leftTop.x);
                
                bool weAreTop = (id.y == leftTop.y);
                
                float leads[4];
                
                leads[0] = leadIndex.x;
                leads[1] = leadIndex.y;
                leads[2] = leadIndex.z;
                leads[3] = leadIndex.w;

                bool validLead[4];
                
                validLead[0] = (leads[0] >= 0.0);
                validLead[1] = (leads[1] >= 0.0);
                validLead[2] = (leads[2] >= 0.0);
                validLead[3] = (leads[3] >= 0.0);
                
                bool weAreLead[4];
                
                weAreLead[0] = (id.x == leads[0]);
                weAreLead[1] = (id.x == leads[1]);
                weAreLead[2] = (id.x == leads[2]);
                weAreLead[3] = (id.x == leads[3]);
                
                bool needSwap[4];
                
                needSwap[0] = (leftTop.x != leads[0]) && validLead[0];
                needSwap[1] = (leftTop.x != leads[1]) && validLead[1];
                needSwap[2] = (leftTop.x != leads[2]) && validLead[2];
                needSwap[3] = (leftTop.x != leads[3]) && validLead[3];
                
                    //
                    
                vec2 divisorPos[4];
                
                for(int i = 0; i < 4; ++i)
                {
                    divisorPos[i].x = needSwap[i] ? (weAreLead[i] ? leftTop.x : (weAreLeft && validLead[i] ? leads[i] : id.x)) : id.x;
                    divisorPos[i].y = leftTop.y;
                }

                    // 
                
                vec2 leadValuePos[4];
                
                for(int i = 0; i < 4; ++i)
                {
                    leadValuePos[i].x = validLead[i] ? leads[i] : id.x;   
                    leadValuePos[i].y = id.y;
                }

                    //
                
                vec2 leadDivisorPos[4];
                
                for(int i = 0; i < 4; ++i)
                {
                    leadDivisorPos[i].x = leadValuePos[i].x;  
                    leadDivisorPos[i].y = leftTop.y;
                }
                
                    //
                
                vec2 valuePos[4];
                
                for(int i = 0; i < 4; ++i)
                {
                    valuePos[i].x = divisorPos[i].x;  
                    valuePos[i].y = id.y;
                }
                    
                    //
                    
                float divisor[4];
                
                for(int i = 0; i < 4; ++i)
                {
                    divisor[i] = readInput(matrix, buildAddress(addrOffset, addrUnit, divisorPos[i]))[i];    
                }
                
                float leadValue[4];
                
                for(int i = 0; i < 4; ++i)
                {
                    leadValue[i] = readInput(matrix, buildAddress(addrOffset, addrUnit, leadValuePos[i]))[i];      
                }
                
                float leadDivisor[4];
                
                for(int i = 0; i < 4; ++i)
                {
                    leadDivisor[i] = readInput(matrix, buildAddress(addrOffset, addrUnit, leadDivisorPos[i]))[i];
                }
                
                float value[4];
                
                for(int i = 0; i < 4; ++i)
                {
                    value[i] = readInput(matrix, buildAddress(addrOffset, addrUnit, valuePos[i]))[i];    
                }
                
                    //
                
                float compLead[4];
                
                for(int i = 0; i < 4; ++i)
                {
                    compLead[i] = safeDivide(leadValue[i], leadDivisor[i]); 
                }
                
                float comp[4];

                for(int i = 0; i < 4; ++i)
                {
                    comp[i] = safeDivide(value[i], divisor[i]); 
                }
                
                vec4 res;
                
                for(int i = 0; i < 4; ++i)
                {
                    res[i] = weAreLeft ? compLead[i] : ((abs(divisor[i]) > 0.0) ? compLead[i] - comp[i] : value[i]);
                }

                writeOutput(res);   
            }
        </script>

        <script type="x-shader/x-fragment" id="eliminator3">
            // #define WIDTH
            // #define HEIGHT
            
            // WIDTH is N
            // HEIGHT is (N + 1)
            
                // matrix is augmented with vector and transposed (so vector is last row)
            
            uniform highp sampler2D matrix;
            
                // 2D-dispatch coord                
            
            uniform vec2 leftTop;
            
            uniform float leadIndex;
            
                // 2D fetch coords helpers
                
            const vec2 addrUnit = vec2(1.0, 1.0) / vec2(WIDTH, HEIGHT);
            const vec2 addrOffset = vec2(0.5, 0.5) * addrUnit;

                //
                
            void main()
            {
                    // we have 2D-identity
                    
                vec2 id = getThreadId();
                
                    //
                
                bool weAreLeft  = (id.x == leftTop.x);
                bool weAreTop   = (id.y == leftTop.y);
                bool weAreLead  = (id.x == leadIndex);

                bool validLead  = (leadIndex >= 0.0);

                bool needSwap   = (leftTop.x != leadIndex) && validLead;
                
                    //
                    
                vec2 divisorPos;
                
                divisorPos.x = needSwap ? (weAreLead ? leftTop.x : (weAreLeft && validLead ? leadIndex : id.x)) : id.x;
                divisorPos.y = leftTop.y;

                float divisor = readFloat(matrix, buildAddress(addrOffset, addrUnit, divisorPos));
                    
                    //
                    
                vec2 valuePos;

                valuePos.x = divisorPos.x;  
                valuePos.y = id.y;

                float value = readFloat(matrix, buildAddress(addrOffset, addrUnit, valuePos));

                    // 
                
                vec2 leadValuePos;
                
                leadValuePos.x = validLead ? leadIndex : id.x;
                leadValuePos.y = id.y;

                float leadValue = readFloat(matrix, buildAddress(addrOffset, addrUnit, leadValuePos));

                    //
                
                vec2 leadDivisorPos;

                leadDivisorPos.x = leadValuePos.x;  
                leadDivisorPos.y = leftTop.y;

                float leadDivisor = readFloat(matrix, buildAddress(addrOffset, addrUnit, leadDivisorPos));

                    //
                
                float compLead = safeDivide(leadValue, leadDivisor);
                
                float comp = safeDivide(value, divisor);

                float res = weAreLeft ? compLead : ((abs(divisor) > 0.0) ? compLead - comp : value);

                    //
                    
                writeFloat(res);   
            }
            
        </script>
        
    </body>
</html>
